# Chapter 9

# 重新审视并发

在内核设计中，同时获得良好的并行性能、正确性和易于理解的代码是一个巨大的挑战。使用锁的直接方式是实现正确性的最佳途径，但并不总是可行。本章节重点介绍了 xv6 强制锁在复杂应用中的例子，以及 xv6 在一些情况下使用类似锁的技术但并非锁。

## 锁模式

对于缓存的项目常常是锁的挑战。例如，最多`NBUF` 个磁盘块的副本。对于给定的磁盘块，缓存中最多有一个副本是至关重要的；否则，不同的进程可能会对应该是相同块的不同副本进行冲突更改。每个缓存块存储在一个 `struct buf` 中(kernel/buf.h:1)。`struct buf` 有一个锁字段，有助于确保每次只有一个进程使用给定的磁盘块。但该锁并不够用：如果块根本没有缓存在缓存中，并且两个进程同时想使用它怎么办？由于还没有缓存该块，因此没有可以锁定的`struct buf`。xv6 处理此情况的方法是，将与缓存块标识符集合关联的另一个锁（`bcache.lock`）。需要检查块是否设置为缓存块的代码必须持有 `bcache.lock`。代码找到所需的块和 `struct buf` 后，即可释放 `bcache.lock` 并锁定特定块。这是一种常见的模式：一组项目有一个锁，每个项目有一个锁。

通常情况下，获取锁的函数会在执行期间释放锁。但更精确的方式是，锁定从一连串必须按照原子操作执行的操作开始时开始，并在该操作结束时释放。如果序列在不同的函数、不同的线程或不同的 CPU 上开始或结束，则锁定获取和释放必须执行相同的操作。锁的作用是强制其他使用进行等待，而不是将数据固定到特定的代理。`yield` 中的 `acquire` 就是一个示例，它的作用是在任何进程中获取锁。另一个示例是，在读取磁盘时代码通常休眠；它可能在另一个 CPU 上唤醒，这意味着锁可以在不同 CPU 上获取和释放。

释放由对象中嵌入的锁保护的对象是一个微妙的问题，因为仅拥有锁无法保证释放的正确性。问题在某个其他线程正在等待并在函数 `acquire` 中使用对象时出现；释放对象隐式释放了嵌入的锁，这将导致等待线程失效。一种解决方法是跟踪对象存在的引用次数，因此仅当最后一个引用消失时才会释放该对象。在 `pipeclose` 中，`pi->readopen` 和 `pi->writeopen` 记录了管道是否具有引用它的文件描述符。

通常情况下，我们会在一组相关项目的读取和写入序列周围看到锁；只要其他线程也锁定，这些锁就可以确保其他线程只看到更新的完整序列。那么如果更新是对单个共享变量的简单写入，该怎么办？例如，`setkilled` 和 `killed` 在其对 `p->killed` 的简单使用周围进行锁定。如果没有锁，则其中一个线程可能在另一个线程读取该变量的同时写入 `p->killed`。这是一种竞争状态，且 C 语言规范指出，竞争状态会导致未定义行为，这意味着程序可能会崩溃或产生错误的结果(参考:[c内存模型](https://en.cppreference.com/w/c/language/memory_model))。锁避免了这种竞争并避免了未定义行为。

竞争状态会破坏程序的原因之一是，如果没有锁或等效的结构，编译器可能会生成读取和写入内存的机器代码，其与原始的 C 代码完全不同。例如，调用 `killed` 的线程的机器代码可以将 `p->killed`复制到寄存器中，并仅读取该缓存值；这意味着线程可能永远不会看到任何对 `p->killed` 的写入。锁可以防止这种缓存。

## 类锁模式

在许多地方，xv6使用引用计数或锁中的标志的方式，表明对象已经被分配并且不应该被释放或重新使用。进程的`p->state`以及`file`、`inode`和`buf`结构中的引用计数都是如此。在每种情况下，锁保护标志或引用计数，但后者防止了对象过早地被释放。

文件系统使用`struct inode`的引用计数作为一种共享锁，可以被多个进程所持有，以避免在代码使用普通锁时出现死锁。对于每个路径名组件命名的目录，`namex`必须以循环的方式释放每个锁，因为如果它持有多个锁，就可能会在路径名包含点（比如`a/./b`）时死锁。如果它与涉及目录和`=`的并发查找死锁，那么它也可能会死锁。正如第8章所解释的那样，解决方案是循环将目录节点沿着引用计数递增但未锁定的方式传递到下一次迭代中。

一些数据项在不同的时间受到不同机制的保护，并且有时可能会隐含地被xv6代码的结构保护，而不是显式地被锁所保护。例如，当一个物理页面被释放时，它由`kmem.lock`保护，由另一个锁（嵌入在`pi->lock`中）保护。如果将页面重新分配到新进程的用户内存中，则根本没有使用锁进行保护。相反，分配器不会将该页面分配给其他任何进程（直到它被释放为止），从而保护它免受并发访问。新进程内存的所有权是复杂的：首先，父进程在`fork`中分配和操作它，然后子进程使用它，最后（在子进程退出后）父进程再次拥有该内存并将其传递给`kfree`。这里有两个教训：数据对象在其生命周期的不同阶段可能以不同的方式受到并发保护，并且保护可能采用隐式结构而不是显式锁。

最后一个类似于锁的例子是需要在中断周围禁用中断的情况。这是因为调用方的原因是要实现在计时器中断强制进行上下文切换并将进程移动到不同的CPU方面的原子性。

## 无锁

在少数几个地方，xv6没有锁就共享可变数据。其中之一是自旋锁的实现，虽然可以将RISC-V原子指令视为依赖于硬件实现的锁。另一个是`main.c`中的`started`变量，它在CPU零完成初始化xv6之前运行；`volatile`确保编译器实际生成装载和存储指令。

Xv6包含这样的情况：一个CPU或线程写入某些数据，另一个CPU或线程读取该数据，但没有专门的锁用于保护该数据。例如，在`fork`中，父进程写入子进程的用户内存页，并且子进程（可能在不同的CPU上的另一个线程）读取这些页；没有锁显式地保护这些页。这不是严格的锁问题，因为子进程在父进程完成写入之后才开始执行。这是潜在的记忆顺序问题（请参见第6章），因为如果没有内存屏障，就没有理由期望一个CPU会看到另一个CPU的写入。但由于父进程释放了锁，并且子进程在启动时获取了锁，因此`acquire`和`release`中的记忆屏障确保子进程的CPU看到了父进程的写入。

## 并行性

在保证正确性的情况下，锁主要是抑制并行性的一种方式。因为性能也很关键，内核设计者常常需要思考如何使用锁，使其既能保证正确性，又能允许并行性。虽然xv6不是专门针对高性能设计的，但考虑哪些xv6操作可以并行执行，哪些可能会与锁发生冲突还是有益的。

在xv6中，管道是一个具有相当不错并行性的例子。每个管道都有自己的锁，因此不同的进程可以在不同的CPU上并行读写不同的管道。对于给定的管道，但是写进程和读进程必须等待彼此释放锁，他们不能同时读/写相同的管道。另外值得注意的是，当空管道读取（或满管道写入）时必须阻塞，但这不是因为锁的机制导致的。

上下文切换是一个更复杂的例子。两个内核线程，在各自的CPU上执行，可以同时调用`yield`、`sched`和`swtch`，这些调用将并行执行。这些线程都持有锁，但是它们是不同的锁，因此它们不必等待对方。然而一旦进入`scheduler`，两个CPU在搜索进程表中的`RUNNABLE`进程时可能会发生锁冲突。也就是说，在上下文切换期间，xv6可能会获得多个CPU的性能优势，但可能并不如它本来可以得到的多。

另一个例子是并发调用来自不同进程在不同CPU上运行的`fork`。这些调用可能需要等待`pid_lock`和`kmem.lock`以及需要搜索进程表中`UNUSED`进程所需的每个进程锁。另一方面，这两个调用进程可以并行地复制用户内存页和格式化页表。

在上述例子中，每种情况下的锁定方案都会在某些情况下降低并行性能。在每种情况下，都可以使用更为复杂的设计来获得更多的并行性。是否值得取决于细节：相关操作被调用的频率、代码花费多长时间拥有一个冲突的锁，同时运行发生冲突的CPU数量，以及其他部分代码是否限制了瓶颈等等。很难猜测是否给定的锁定方案会导致性能问题，或者新设计是否显着更好，因此通常需要在实际工作负载上进行衡量。

## 练习

1. 修改xv6的管道实现，允许不同核心上的读和写同时执行到同一管道中。
2. 修改xv6的`scheduler()`，以减少不同核心在同时查找可运行进程时的锁争用。
3. 消除xv6 `fork()`中的某些串行化