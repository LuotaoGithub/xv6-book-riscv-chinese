# Chapter 2

# 操作系统结构

操作系统的一个重要要求是同时支持多项活动。例如，在第1章中描述的系统调用接口中，进程可以使用 `fork` 启动新进程。操作系统必须在这些进程之间进行时间分配，以共享计算机的资源。例如，即使进程数量超过了硬件CPU的数量，操作系统也必须确保所有进程都有机会执行。操作系统还必须安排进程之间的隔离，这意味着如果一个进程存在错误并且发生故障，它不应当影响不依赖于有错误的进程的其他进程。然而，完全的隔离过于严格，因为进程之间应该可以有意地相互交互，管道就是一个例子。因此，操作系统必须满足三个要求：多路复用、隔离、和相互作用。

本章概述了操作系统如何组织来实现这三个要求。事实上有很多种方法可以实现这些要求，但是本书关注的是中心化的*宏内核*设计，这种设计被许多 Unix 操作系统所使用。本章还概述了在 xv6 中的进程，这是 xv6 中实现隔离的单位，以及 xv6 启动时第一个进程的创建过程。

Xv6 运行在一个*多核* RISC-V 微处理器上，它的许多低级功能（例如进程实现）都是特定于 RISC-V 的。RISC-V 是一个64位的 CPU，而 xv6 是用“LP64” C 编写的，这意味着 C 语言的 long 和 pointer 是64位，但 int 是32位。本书假定读者对某种体系结构已经有一些底层编程经验，并将在一些概念被提及时介绍 RISC-V 的特定概念。RISC-V 的一个有用的参考文献是“RISC-V Reader: An Open Architecture Atlas”~。用户层的ISA和特权级架构是官方的规范。

完整计算机中的 CPU 周围都是支持硬件，其中许多是 I/O 接口形式。Xv6 是为 qemu 的“-machine virt”选项模拟的支持硬件编写的，其中包括 RAM，一个包含启动代码的 ROM，与用户的键盘/屏幕连接的串行连接，以及一个用于存储的磁盘。

## 物理资源的抽象

当遇到操作系统时，人们可能会问的第一个问题是为什么需要操作系统？也就是说，可以将图1.2 中的系统调用实现为一个库，并将其链接到应用程序中。在这个计划中，每个应用程序甚至可以有自己的定制库来满足其需要。应用程序可以直接与硬件资源进行交互，并以最好的方式使用这些资源（例如，以实现高性能或可预测性能）。一些针对嵌入式设备或实时系统的操作系统就是按这种方式组织的。

这种库方法的缺点是，如果有多个应用程序在运行，这些应用程序必须表现良好。例如，每个应用程序必须定期让出CPU，以便其他应用程序可以运行。如果所有应用程序都互相信任且没有错误，这种合作式的时间共享计划可能是可行的。但通常情况下，应用程序不信任彼此，并且可能有错误，所以通常需要比合作式的计划提供更强的隔离。

为实现强隔离，有助于禁止应用程序直接访问敏感的硬件资源，并将这些资源抽象为服务。例如，Unix应用程序只能通过文件系统的`open`、`read`、`write`和`close`系统调用与存储进行交互，而不能直接读写磁盘。这为应用程序提供了路径名的便利性，允许操作系统（作为接口实现者）来管理磁盘。即使不考虑隔离，有意互动的程序（或仅希望彼此不干扰的程序）也很可能发现文件系统比直接使用磁盘更方便。

同样地，Unix通过透明地在进程之间切换硬件CPU，并在必要时保存和恢复寄存器状态，使得应用程序不必意识到时间共享。这种透明度允许操作系统即使一些应用程序陷入无限循环也可以共享CPU。

另一个例子是，Unix进程使用`exec`来构建它们的内存映像，而不是直接与物理内存交互。这使得操作系统可以决定将进程放置在内存中的位置；如果内存不足，操作系统甚至可能将进程的一些数据存储在磁盘上。 `exec`还提供了一个方便的文件系统，用于存储可执行程序映像。

Unix进程之间的许多交互方式是通过文件描述符（file descriptors）进行的。文件描述符不仅抽象了许多细节（例如，管道或文件中的数据存储在何处），而且它们的定义方式也简化了交互。例如，如果管道中的一个应用程序失败，内核会为管道中的下一个进程生成一个文件结尾信号。

图1.2中的系统调用接口被精心设计，既提供程序员的便利性，又有可能提供强隔离。Unix接口不是抽象资源的唯一方式，但它已经被证明是一个非常好的方式。

## 2.2 用户模式、特权模式和系统调用

强隔离要求应用程序和操作系统之间有一个硬边界。如果应用程序出错，我们不希望操作系统或其他应用程序也出错。相反，操作系统应该能够清理失败的应用程序并继续运行其他应用程序。为了实现强隔离，操作系统必须安排应用程序不能修改（甚至读取）操作系统的数据结构和指令，并且应用程序不能访问其他进程的内存。

CPU为强隔离提供了硬件支持。例如，RISC-V有三种模式，CPU可以在其中执行指令：*机器模式*，*超级用户模式*和*用户模式*。在机器模式下执行的指令拥有完全的特权；CPU在机器模式下启动。机器模式主要用于配置计算机。Xv6在机器模式下执行几行指令，然后切换到超级用户模式。

在超级用户模式下，CPU允许执行*特权指令*：例如，启用和禁用中断，读取和写入保存页表地址的寄存器等。如果处于用户模式下的应用程序尝试执行特权指令，则CPU不执行该指令，而是切换到超级用户模式，以便超级用户模式下的代码可以终止应用程序，因为应用程序执行了不应该执行的操作。第1章的图1.1说明了这种组织方式。应用程序只能执行用户模式指令（例如，加法等），称为运行在*用户空间*，而在超级用户模式下运行的软件也可以执行特权指令，称为运行在*内核空间*。运行在内核空间（或超级用户模式下）的软件称为内核。

想要调用内核函数（例如，xv6中的`read`系统调用）的应用程序必须转换到内核；应用程序不能直接调用内核函数。CPU提供了一条特殊指令，可以将CPU从用户模式切换到超级用户模式，并在内核指定的入口点进入内核（RISC-V提供了`ecall`指令用于此目的）。一旦CPU切换到超级用户模式，内核就可以验证系统调用的参数（例如，检查传递给系统调用的地址是否是应用程序的内存的一部分），决定应用程序是否允许执行请求的操作（例如，检查应用程序是否被允许写指定的文件），然后拒绝或执行它。重要的是，内核控制超级用户模式转换的入口点；如果应用程序可以决定内核入口点，恶意应用程序可以在跳过参数验证的地方进入内核。

一个重要的设计问题是哪些操作系统部分应该在超级用户模式下运行。其中一个可能的做法是将整个操作系统都放在内核中，以便所有系统调用的实现都在超级用户模式下运行。这种组织方式被称为*宏内核*。

在这种组织中，整个操作系统都以完全的硬件特权运行。这种组织方式很方便，因为操作系统设计者不需要决定哪些操作系统部分不需要完整的硬件特权。此外，不同部分的操作系统更容易相互协作。例如，操作系统可能有一个缓冲区高速缓存，可以由文件系统和虚拟存储系统共享。

## 内核结构

单内核组织的缺点是操作系统不同部分之间的接口通常比较复杂（后面的内容中我们会看到），因此操作系统开发者很容易出错。在单内核中，一个错误将是致命的，因为超级用户模式下的错误通常会导致内核崩溃。如果内核崩溃，计算机就会停止工作，这也意味着所有应用程序都会失败。计算机必须重新启动才能重新开始工作。

为了减少内核中出错的风险，操作系统设计者可以最小化在超级用户模式下运行的操作系统代码数量，将操作系统的大部分代码放在用户模式下运行。这种内核组织方式称为*微内核*。

![2.1](fig/2.1.svg)

图2.1说明了这种微内核设计。在图中，文件系统作为用户级进程运行。作为进程运行的操作系统服务称为服务器。为了允许应用程序与文件服务器交互，内核提供了一种进程间通信机制，用于从一个用户模式进程发送消息到另一个进程。例如，如果像shell这样的应用程序想要读取或写入文件，它会向文件服务器发送消息并等待响应。

在微内核中，内核接口由一些低级函数组成，用于启动应用程序、发送消息、访问设备硬件等。这种组织方式使得内核相对简单，因为大部分操作系统都驻留在用户级别服务器中。

在实际中，单内核和微内核都很流行。许多Unix内核是单内核的。例如，Linux具有单内核，尽管一些操作系统功能作为用户级别服务器运行（例如，窗口系统）。Linux为操作系统密集型应用程序提供了高性能，部分原因是内核的子系统可以紧密集成。

像Minix、L4和QNX这样的操作系统采用了服务器式的微内核结构，在嵌入式环境中得到广泛应用。L4的一个变体seL4足够小，以至于已经验证了对内存安全和其他安全属性~。

操作系统开发人员之间对于哪种组织方式更好存在着很多争论，没有明确的证据支持任何一种。此外，这取决于“更好”的含义：更快的性能、更小的代码大小、内核的可靠性、完整操作系统的可靠性（包括用户级别服务）、等等。

还有实际考虑可能比组织方式更重要。一些操作系统具有微内核，但出于性能原因在内核空间运行了一些用户级别服务。一些操作系统具有单内核，因为它们最初就是这样的，移动到纯微内核组织很少有动力，因为新功能可能比重写现有操作系统以适应微内核设计更为重要。

从本书的角度来看，微内核和单内核操作系统共享许多关键思想。它们实现系统调用、使用页表、处理中断、支持进程、使用锁进行并发控制、实现文件系统等。本书关注这些核心思想。

Xv6是作为单内核实现的，就像大多数Unix操作系统一样。因此，xv6内核接口对应于操作系统接口，并且内核实现了完整的操作系统。由于xv6没有提供很多服务，所以它的内核比一些微内核小，但是概念上xv6是单内核的。

## 代码:xv6 结构

| 文件            | 描述                       |
| ------------- | ------------------------ |
| bio.c         | 用于磁盘块缓存的代码。              |
| console.c     | 连接用户键盘和屏幕                |
| entry.S       | 最初引导指令                   |
| exec.c        | exec()系统调用               |
| file.c        | 文件描述符支持                  |
| fs.c          | 文件系统                     |
| kalloc.c      | 物理页面分配器                  |
| kernelvec.S   | 处理来自内核和计时器中断的陷阱          |
| log.c         | 文件系统日志和崩溃恢复              |
| main.c        | 在引导过程中控制其他模块的初始化         |
| pipe.c        | 管道                       |
| plic.c        | RISC-V中断控制器              |
| printf.c      | 格式化输出到控制台                |
| proc.c        | 进程和调度                    |
| sleeplock.c   | 可让出CPU的锁                 |
| spinlock.c    | 不可让出CPU的锁                |
| start.c       | 早期机器模式启动代码               |
| string.c      | C字符串和字节数组库               |
| swtch.S       | 线程切换                     |
| syscall.c     | 将系统调用分派给处理函数             |
| sysfile.c     | 与文件有关的系统调用               |
| sysproc.c     | 与进程相关的系统调用               |
| trampoline.S  | 汇编代码，用于在用户空间和内核空间之间切换    |
| trap.c        | C代码，用于处理和返回陷阱和中断         |
| uart.c        | 串口控制台设备驱动                |
| virtio_disk.c | 磁盘设备驱动                   |
| vm.c          | 管理页表和地址空间                |
| fig2.2        | Xv6 kernel source files. |

xv6内核源代码位于`kernel/` 子目录中。源代码按照大致的模块化概念划分为文件；图2.2列出了这些文件。各个模块间的接口在`defs.h` (kernel/defs.h)中定义。

## 进程概览

在xv6和其他Unix操作系统中，隔离的基本单元是进程（process）。进程抽象可以避免一个进程破坏或窥探另一个进程的内存、CPU、文件描述符等等，并防止进程破坏内核本身，让进程无法破坏内核的隔离机制。内核必须小心地实现进程抽象，因为有漏洞或恶意应用程序可能会欺骗内核或硬件进行危险操作（例如，规避隔离）。内核用于实现进程的机制包括用户/监管员模式标志、地址空间以及线程的时间片分配等。

为了帮助实现隔离，进程抽象为程序提供了一个私有机器的假象。进程为程序提供了一个看似私有的内存系统，即地址空间，其他进程无法读取或写入。进程还为程序提供了一个似乎是其自己的CPU来执行程序的指令。

xv6使用页表（由硬件实现）为每个进程提供其自己的地址空间。RISC-V页表将虚拟地址（RISC-V指令操作的地址）转换为物理地址（CPU芯片发送到主存储器的地址）。
![2.3](fig/2.3.svg)

xv6为每个进程维护一个单独的页表，以定义该进程的地址空间。如图2.3所示，地址空间包括从虚拟地址零开始的进程用户内存。指令首先出现，然后是全局变量，接着是栈，最后是进程可以根据需要扩展的“堆”区域（用于malloc）。有许多因素限制进程地址空间的最大大小：RISC-V上的指针宽度为64位；当硬件在页表中查找虚拟地址时，仅使用低39位；xv6仅使用其中的38位。因此，最大地址为$2^38-1=0x3fffffffff$, 即`MAXVA`(kernel/riscv.h:363)。在地址空间的顶部，xv6保留一页用于*trampoline*和映射进程的*trapframe*。xv6使用这两个页面进行内核的转换；trampoline页面包含从内核进入和退出的代码，并且映射trapframe是保存/恢复用户进程状态所必需的，我们将在第4章中详细解释。

xv6内核为每个进程维护许多状态片段，并将其集中到一个`struct proc`中。一个进程最重要的内核状态部分是它的页表、内核栈和运行状态。我们使用`p->xxx`符号来引用`proc`结构中的元素；例如，`p->pagetable`是指向进程页表的指针。

每个进程都有一个执行线程（或简称*线程*），用于执行该进程的指令。线程可以挂起并稍后恢复。为了在进程之间透明地切换，内核会挂起当前正在运行的线程并恢复其他进程的线程。线程的许多状态（局部变量、函数调用返回地址）存储在其堆栈上。每个进程都有两个堆栈：一个用户堆栈和一个内核堆栈（`p->kstack`）。当进程执行用户指令时，只使用其用户堆栈，而其内核堆栈是空的。当进程进入内核（用于系统调用或中断）时，内核代码在该进程的内核堆栈上执行；在进程位于内核中时，其用户堆栈仍包含已保存的数据，但不会被主动使用。进程的线程在使用其用户堆栈和内核堆栈之间交替。内核堆栈是独立的（并受到用户代码的保护），以便即使进程已破坏其用户堆栈，内核仍可以执行。

进程可以通过执行RISC-V `ecall`指令来进行系统调用。该指令将硬件特权级提高并将程序计数器更改为内核定义的入口点。入口点处的代码切换到一个内核堆栈，并执行实现系统调用的内核指令。当系统调用完成时，内核将切换回用户堆栈，并通过调用`sret`指令返回到用户空间，该指令降低硬件特权级并在系统调用指令之后恢复执行用户指令。进程的线程可以在内核中“阻塞”，等待I/O的完成，并在I/O完成后从离开的地方继续执行。

`p->state` 表示进程是已分配的、准备就绪、正在运行、正在等待I/O还是正在退出。

`p->pagetable`保存进程的页表，格式符合RISC-V硬件的期望。xv6在执行该进程的用户空间时，会要求页面硬件使用进程的`p->pagetable`。进程的页表还充当记录已用于存储进程内存的物理页地址的记录。

总之，进程捆绑了两个设计思想：地址空间以给进程提供自己内存的假象，以及线程以给进程提供其自己CPU的假象。在xv6中，一个进程由一个地址空间和一个线程组成。在真实操作系统中，进程可能具有多个线程，以利用多个CPU。

## 代码：启动xv6，第一个进程和系统调用

为了让xv6更加具体，我们将概述内核如何启动并运行第一个进程。随后的章节将更详细地描述在此概述中出现的机制。

当RISC-V计算机上电时，它自我初始化并运行存储在只读内存中的引导加载程序。引导加载程序将xv6内核加载到内存中。然后，在机器模式下，CPU从`_entry`开始执行xv6。RISC-V启动时禁用了分页硬件：虚拟地址直接映射到物理地址。

加载程序将xv6内核加载到物理地址`0x80000000`的内存中。之所以将内核放置在`0x80000000`而不是`0x0`的地址上，是因为地址范围`0x0:0x80000000`包含I/O设备。

在`_entry`中的指令设置堆栈，以便xv6可以运行C代码。xv6在文件`start.c`中声明了一个初始堆栈`stack0`的空间。在`_entry`处的代码将堆栈指针寄存器`sp`加载到堆栈的顶部地址`stack0+4096`，因为RISC-V上的堆栈向下增长。现在内核有了一个堆栈，`_entry`调用C代码中的`start`。
函数`start`执行一些只允许在机器模式下进行的配置，然后切换到监管模式。为了进入监管模式，RISC-V提供指令`mret`。该指令通常用于返回以前从监管模式调用的机器模式。在`start`中并没有从这样的调用返回，而是设置了一些内容，就好像有一个这样的调用：在寄存器`mstatus`中将前一个特权模式设置为监管模式，将返回地址设置为`main`的地址，方法是将`main`的地址写入寄存器`mepc`，在监管模式下通过将`0`写入页表寄存器`satp`禁用虚拟地址转换，并将所有中断和异常委托给监管模式。

在跳转到监管模式之前，`start`执行了一个任务：将时钟芯片配置为生成定时器中断。完成这项工作后，`start`往监管模式“返回”调用`mret`。这将导致程序计数器更改为`main`。

在`main`初始化了几个设备和子系统后，它通过调用`userinit`创建第一个进程。第一个进程执行了一个用RISC-V汇编编写的小程序，在xv6中进行了第一个系统调用。`initcode.S`(user/initcode.S:3)将`exec`系统调用的编号`SYS_EXEC`加载到寄存器`a7`中，然后调用`ecall`重新进入内核。

内核在`syscall` `SYS_EXEC`中使用寄存器`a7`中的编号调用`sys_exec`。正如我们在第1章中所见，`exec`将当前进程的内存和寄存器替换为新的程序（在这种情况下是`/init`）。

完成`exec`后，内核在`/init`进程中返回到用户空间。如果需要，`init`会创建一个新的控制台设备文件，然后将其作为文件描述符0、1和2打开。然后，在控制台上启动一个shell程序。系统启动完成。

## 安全模型

你可能想知道操作系统如何处理有缺陷或恶意代码。由于应对恶意行为要比处理意外错误难得多，因此合理地将此主题视为与安全相关。以下是操作系统设计中典型安全假设和目标的高层概述。

操作系统必须假设进程的用户级代码会尽力破坏内核或其他进程。用户代码可能尝试在其允许的地址空间之外引用指针；它可能尝试执行任何RISC-V指令，甚至针对非用户代码的指令；它可能尝试读取和写入任何RISC-V控制寄存器；它可能尝试直接访问设备硬件；它可能传递巧妙的值给系统调用，试图欺骗内核崩溃或做一些愚蠢的事情。内核的目标是限制每个用户进程，使其只能读/写/执行自己的用户内存，使用32个通用RISC-V寄存器，并以系统调用允许的方式影响内核和其他进程。内核必须防止任何其他操作。这通常是内核设计中的绝对要求。

内核自身的代码期望完全不同。假定内核代码是由善意和细心的程序员编写的。预期内核代码没有漏洞，当然也不包含任何恶意代码。这种假设影响了我们对内核代码的分析。例如，有许多内部内核函数（例如自旋锁），如果内核代码使用不正确，则会引起严重问题。在检查任何特定的内核代码时，我们希望确信它的行为是正确的。然而，我们假设内核代码通常是正确的编写的，并且遵循有关使用内核自己的函数和数据结构的所有规则。在硬件层面上，假定RISC-V CPU、RAM、磁盘等按照文档中宣传的方式运作，没有硬件缺陷。

当然，在现实生活中事情并不那么简单。很难防止巧妙的用户代码通过消耗内核保护资源 - 磁盘空间、CPU时间、进程表槽等 - 使系统无法使用（或导致它崩溃）。编写无漏洞的代码或设计无漏洞的硬件通常是不可能的；如果恶意用户代码的编写者意识到内核或硬件存在漏洞，则会利用它们。即使在成熟、广泛使用的内核（例如Linux）中，人们不断地发现新的漏洞~。在内核中设计安全保障措施，以防它存在漏洞是值得的：断言、类型检查、堆栈保护页等。最后，用户代码和内核代码之间的区别有时模糊不清：一些拥有特权的用户级进程可能提供必要的服务，并且在某些操作系统中，特权用户代码可以将新的代码插入内核中（例如Linux的可加载内核模块）。

## 实际情况

大多数操作系统都采用了进程的概念，并且大多数进程看起来类似于xv6。然而，现代操作系统支持在进程内支持多个线程，以允许单个进程利用多个CPU。在进程内支持多个线程涉及了很多xv6没有的机制，包括潜在的接口更改（例如Linux的`clone`，是`fork`的一种变体），以控制进程中线程共享的方面。

## 练习

1. 向xv6添加一个系统调用，用于返回可用空闲内存的数量。
