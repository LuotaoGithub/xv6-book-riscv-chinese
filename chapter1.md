# Chapter 1

# 操作系统接口

操作系统的任务是分享计算机资源，同时提供比硬件本身更有用的服务，特别是编写学术论文、科技文献、书籍等正式文件时更加适用。操作系统负责管理和抽象底层硬件，使诸如文字处理软件不必关心所使用的硬盘。同时，操作系统也需要在多个程序之间分享计算机硬件，以使它们同时运行(或看起来是同时运行)。最后，操作系统通过受控的方式，使程序之间能够相互作用，以便它们可以共享数据或协同工作。

操作系统通过接口向用户程序提供服务。然而，设计一个好的接口是很困难的。一方面，我们希望接口简单而狭窄，因为这样可以更容易地正确实现。另一方面，我们可能会诱惑向应用程序提供许多复杂的功能。解决这种紧张关系的技巧在于设计依赖于一些机制的接口，这些机制可以结合在一起提供更多的通用性。

这本书以一个具体的操作系统，xv6作为例子，阐述操作系统的概念。该操作系统提供了Ken Thompson和Dennis Ritchie的Unix操作系统介绍的基本接口，并模仿了Unix的内部设计。Unix提供了一个狭窄的接口，其机制结合很好，提供了惊人的通用性。这个接口非常成功，以至于现代操作系统——BSD、Linux、macOS、Solaris，甚至在较小的程度上，Microsoft Windows，都采用了类似Unix的接口。了解xv6是了解任何这些系统和许多其他系统的良好起点。

如图1.1所示，xv6采用了传统的内核(kernel)形式，它是一种特殊的程序，为正在运行的程序提供服务。每个正在运行的程序，称为进程(process)，都有包含指令、数据和栈的内存。指令实现程序的计算，数据是计算的变量，栈则组织程序的过程调用。一台计算机通常有许多进程，但只有一个内核。

当进程需要调用内核服务时，它会调用操作系统接口中的一个系统调用(system call)。系统调用进入内核；内核执行服务并返回。因此，进程在用户空间(user space)和内核空间(kernel space)之间交替执行。

如后续章节中所详细介绍的那样，内核使用CPU提供的硬件保护机制，以确保在用户空间执行的每个进程只能访问自己的内存。内核在需要实现这些保护的硬件特权下执行；用户程序则不具有这些特权。当用户程序调用系统调用时，硬件会提升特权级别并开始在内核中执行预先安排好的函数。
![1.1](fig/1.1.svg)
内核提供给用户程序的系统调用集合是用户程序看到的接口。xv6内核提供了Unix内核传统提供的一部分服务和系统调用。图1.2列出了xv6的所有系统调用。

本章的其余部分概述xv6的服务，包括进程、内存、文件描述符、管道和文件系统，并且使用代码片段和讨论说明它们以及shell的使用方式。shell对系统调用的使用说明了它们如何被精心地设计。

shell是一个普通的程序，它从用户读取命令并执行它们。shell是一个用户程序，而不是内核的一部分，这说明了系统调用接口的力量：shell没有任何特殊之处。这也意味着shell很容易被替换。因此，现代Unix系统中有各种选择的shell，每个shell都有自己的用户界面和脚本功能。xv6 shell是Unix Bourne shell本质的简单实现。(user/sh.c:1)给出了它的实现。

## 处理器和内存

xv6进程由用户空间内存(指令、数据和栈)和内核的每个进程私有状态组成。 xv6实现的进程采用时间片(time-share)调度，它会在等待执行的一组进程之间透明地切换可用的CPU。当一个进程未在执行时，xv6会保存该进程的CPU寄存器，并在下次运行该进程时恢复这些寄存器。内核为每个进程关联一个进程标识符(PID)。

| 系统调用                                | 描述                                         |
| ----------------------------------- | ------------------------------------------ |
| int fork()                          | 创建一个新的进程，返回子进程的PID。                        |
| int exit(int status)                | 终止当前进程，状态将传递给wait()。没有返回值。                 |
| int wait(int status)                | 等待一个子进程结束，结束状态存储在status中，返回子进程的PID。        |
| int kill(int pid)                   | 终止PID指定的进程。返回0，如果出错返回-1。                   |
| int getpid()                        | 返回当前进程的PID。                                |
| int sleep(int n)                    | 暂停n个时钟滴答。                                  |
| int exec(char file, char argv[])    | 装载并执行带参数的文件，在出错时返回。                        |
| char sbrk(int n)                    | 将进程的内存增长n个字节，返回新内存的起始地址。                   |
| int open(char file, int flags)      | 打开一个文件，标志指示读/写权限。返回一个fd（文件描述符）。            |
| int write(int fd, char buf, int n)  | 将buf中的n个字节写入文件描述符fd中，返回n。                  |
| int read(int fd, char buf, int n)   | 从文件描述符fd中读取n个字节到buf中，返回读取的字节数，若到达文件尾端则返回0。 |
| int close(int fd)                   | 释放打开的文件fd。                                 |
| int dup(int fd)                     | 返回一个指向与fd相同的文件的新文件描述符。\|                   |
| int pipe(int p[])                   | 创建一个管道，将读写文件描述符放入p[0]和p[1]中。               |
| int chdir(char dir)                 | 改变当前目录。                                    |
| int mkdir(char dir)                 | 创建一个新目录。                                   |
| int mknod(char file, int, int)      | 创建设备文件。                                    |
| int fstat(int fd, struct stat st)   | 将打开文件的信息放入st结构体中。                          |
| int stat(char file, struct stat st) | 将命名文件的信息放入st结构体中。                          |
| int link(char file1, char file2)    | 为文件file1创建另一个名称file2。                      |
| int unlink(char *file)              | 移除一个文件。                                    |
| Figure1.2 : Xv6 syscall             |                                            |

一个进程可以使用`fork`系统调用来创建一个新的进程。`fork`将给调用进程的内存(指令和数据)创建一个精确的副本，并在原始进程和新进程中返回。在原始进程中，`fork`返回新进程的PID。在新进程中，`fork`返回0。原始进程和新进程通常称为父进程和子进程。

例如，考虑以下用C编写的程序片段：

```C
int pid = fork();
if(pid > 0){
  printf("parent: child=%d\n", pid);
  pid = wait((int *) 0);
  printf("child %d is done\n", pid);
} else if(pid == 0){
  printf("child: exiting\n");
  exit(0);
} else {
  printf("fork error\n");
}
```

`exit`系统调用使调用进程停止执行并释放资源(如内存和打开的文件)。exit需要一个整数状态参数，通常为0表示成功，1表示失败。 `wait`系统调用返回当前进程已退出(或被杀死)的子进程的PID，并将子进程的退出状态复制到传递给wait的地址。如果调用方的子进程都没有退出，`wait`将等待一个子进程退出。如果调用方没有子进程，`wait`会立即返回-1。如果父进程不关心子进程的退出状态，可以将一个0地址传递给`wait`。

在这个例子中，输出行

```C
parent: child=1234 
child: exiting
```

的顺序可能是任意的(甚至交错的)，这取决于父进程或子进程哪个先到达它的`printf`语句。在子进程退出后，父进程的`wait`返回，导致父进打印

```C
parent: child 1234 is done 
```

虽然子进程最初与父进程具有相同的内存内容，但父进程和子进程正在别使用不同的内存和寄存器:更改一个变量不会影响另一个变量。例如，当`wait`的返回值存储到父进程中的`pid`时，它不会更改子进程中`pid`变量。子进程中`pid`的值仍然为零。

`exec`系统调用用存储在文件系统中的文件中加载的新内存镜像替换调用进程的内存。该文件必须具有特定的格式，指定文件的哪一部分保存指令，哪一部分是数据，从哪个指令开始等等。Xv6使用可执行和链接格式(ELF)，第3章详细讨论了此格式。通常文件是编译程序源代码的结果。当`exec`成功时，它不会返回给调用程序;相反，从文件加载的指令从ELF头中声明的入口点开始执行。`exec`需要两个参数:包含可执行文件的文件名和字符串参数数组。例如：

```C
char *argv[3];

argv[0] = "echo";
argv[1] = "hello";
argv[2] = 0;
exec("/bin/echo", argv);
printf("exec error\n");
```

此代码片段使用以参数列表`echo hello`运行的`/bin/echo`程序实例替换调用程序。大多数程序将忽略参数数组的第一个元素，按照惯例它是程序的名称。

xv6 shell使用上述调用代表用户运行程序。Shell的主结构很简单，详见`main`。主循环使用`getcmd`从用户读取一行输入。然后它调用`fork`，创建 shell 进程的副本，父进程调用`wait`，而子进程运行命令。例如，如果用户在shell中输入`echo hello`''，那么`runcmd`将以`echo hello`''为参数调用。`runcmd`执行实际的命令。对于```echo hello`''，它将调用`exec`。
如果`exec`成功，子进程将执行来自`echo`的指令，而不是执行`runcmd`。在某些点上，`echo`将调用`exit`，这将导致父进程从`main`中的`wait`返回。

你可能想知道为什么`fork`和`exec`未被合并为一次系统调用。我们将在后面看到，Shell利用这种分离来实现I/O重定向。为了避免创建一个重复的进程，然后立即使用`exec`替换它(造成浪费)，操作系统会优化实现`fork`，使用如写时复制(copy-on-write)的虚拟内存技术，详见第4.6节。

xv6隐式分配大部分用户空间内存:`fork`为子进程的内存分配与父进程相同的内存；`exec`为可执行文件分配足够的内存。需要在运行时分配更多内存(例如对于`malloc`)的进程可以调用`sbrk(n)`，将数据内存增加`n`字节；`sbrk`将返回新的内存位置。

## I/O 和 文件描述符

文件描述符(file descriptor)是一个表示进程可以读取或写入的内核管理对象的小整数值。进程可以通过打开文件、目录或设备、创建管道或复制现有描述符来获得文件描述符。

为简单起见，我们通常将文件描述符指向的对象称为"文件"；文件描述符接口抽象了文件、管道和设备之间的差异，使它们都看起来像是字节流。我们将输入和输出称为I/O。

在内部，xv6内核使用文件描述符作为进程表中的索引，以便每个进程都有从零开始的私有文件描述符空间。按照惯例，进程从文件描述符0(标准输入)读取数据，将输出写到文件描述符1(标准输出)，并将错误消息写入文件描述符2(标准错误)。正如我们将要看到的那样，Shell利用这一约定来实现I/O重定向和管道。Shell确保始终有三个打开的文件描述符，默认情况下是控制台的文件描述符。

`read`和`write`系统调用读取名为文件描述符的打开文件的字节。调用`read(fd, buf, n)`最多从文件描述符`fd`中读取`n`字节，将它们复制到`buf`里，并返回读取的字节数。每一个指向文件的文件描述符都会有一个偏移量与之关联。`read`从当前文件偏移量读取数据，然后将该偏移值增加被读取的字节数：随后的一个`read`将从第一个`read`返回的字节后的位置继续读取。当没有更多字节可读时，`read`将返回零以表示文件结束。

调用`write(fd, buf, n)`会将`buf`中的`n`字节写入到文件描述符`fd`中，返回写入的字节数。只有在发生错误时才会写入比`n`少的字节。与`read`相似，`write`从当前文件偏移量写入数据，并将该偏移值增加写入的字节数：每个`write`都从之前一个`write`结束的位置开始继续。

以下程序片段（构成程序`cat`的精髓）将数据从标准输入复制到标准输出。如果发生错误，则将消息写入标准错误。

```C
char buf[512];
int n;

for(;;){
  n = read(0, buf, sizeof buf);
  if(n == 0)
    break;
  if(n < 0){
    fprintf(2, "read error\n");
    exit(1);
  }
  if(write(1, buf, n) != n){
    fprintf(2, "write error\n");
    exit(1);
  }
}
```

需要注意的是，代码片段中的`cat`不知道它是从文件、控制台还是管道读取的，同样，`cat`也不知道它是将输出打印到控制台、文件还是其他地方。使用文件描述符和约定输入是文件描述符0，输出是文件描述符1，可以实现简单的`cat`。

系统调用`close`会释放文件描述符，使其可以在未来的`open`、`pipe`或`dup`系统调用中重用(见下文)。新分配的文件描述符始终是当前进程中未使用的最低编号的描述符。

文件描述符和`fork`相互作用，使得I/O重定向易于实现。 `fork`会复制父进程的文件描述符表以及内存，因此子进程的打开文件列表和父进程完全相同。系统调用`exec`替换调用进程的内存，但保留其文件表。这种行为使得Shell可以通过forking实现I/O重定向，重新打开子进程中选定的文件描述符，然后调用`exec`来运行新的程序。下面是Shell运行`cat <input.txt` 命令的简化代码：

```C
char *argv[2];

argv[0] = "cat";
argv[1] = 0;
if(fork() == 0) {
  close(0);
  open("input.txt", O_RDONLY);
  exec("cat", argv);
}
```

当子进程关闭文件描述符0时，`open`保证会使用该文件描述符打开`input.txt`：0将是最小可用的文件描述符。然后，`cat`就是在有文件描述符0(标准输入)指向`input.txt`的情况下执行的。由于这个序列只修改了子进程的描述符，所以父进程的文件描述符没有被更改。

xv6 shell中实现I/O重定向的代码就是这样工作的。回想一下，在代码的这一点上，shell已经创建了子shell，`runcmd`将调用`exec`来加载新程序。

`open`的第二个参数由一组标志组成，表示为位，用于控制`open`的操作。可能的值在文件控制(fcntl)头文件中定义：`O_RDONLY`、`O_WRONLY`、`O_RDWR`、`O_CREATE`和`O_TRUNC`，它们指示`open`打开文件以进行读取、写入或读写，如果文件不存在，则创建文件，并将文件截断为零长度。

现在应该清楚为什么把`fork`和`exec`分开是有帮助的：在这两个调用之间，Shell有机会在不干扰主Shell的I/O设置的情况下重定向子进程的I/O。也可以想象一个假想的`forkexec`系统调用，但用这样的调用进行I/O重定向的选项似乎很麻烦。Shell可以在调用`forkexec`之前修改自己的I/O设置(然后撤销这些修改)；也可以将I/O重定向的指令作为`forkexec`的参数；或者(最不吸引人的)每个像`cat`这样的程序都可以学会自己进行I/O重定向。

虽然`fork`会复制文件描述符表，但每个底层文件偏移量在父进程和子进程之间是共享的。考虑以下例子：

```C
if(fork() == 0) {
  write(1, "hello ", 6);
  exit(0);
} else {
  wait(0);
  write(1, "world\n", 6);
}
```

在这个片段的结尾，附加到文件描述符1的文件将包含数据`hello``world`。父进程中的`write`（由于`wait`的存在，只有在子进程执行结束之后才会运行）从子进程的`write`结束的地方继续写入。这种行为有助于从Shell命令序列中产生顺序输出，例如`(echo hello; echo world) > output.txt`。

系统调用`dup`会复制现有的文件描述符，返回一个指向相同底层I/O对象的新描述符。两个文件描述符共享一个偏移量，就像`fork`复制的文件描述符一样。这是将`hello``world`写入文件的另一种方法：

```C
fd = dup(1);
write(1, "hello ", 6);
write(fd, "world\n", 6);
```

如果两个文件描述符是通过一系列的`fork`和`dup`调用从同一个最初的文件描述符派生出来的，则它们共享一个偏移量。否则，即使它们是通过对同一文件进行`open`调用得到的，文件描述符也不会共享偏移量。`dup`允许Shell实现像这样的命令：`ls existing-file non-existing-file > tmp1 2>&1`。`2>&1`告诉Shell为命令

## 管道(Pipes)

管道是一块小的内核缓冲区， 作为一对文件描述符向进程公开，一个用于读取，另一个用于写入。 将数据写入管道的一端使得该数据能够从管道的另一端进行读取。 管道提供了进程间通信的一种方式。

下面的示例代码运行程序`wc`，并将标准输入连接到管道的读取端。

```C
int p[2];
char *argv[2];

argv[0] = "wc";
argv[1] = 0;

pipe(p);
if(fork() == 0) {
  close(0);
  dup(p[0]);
  close(p[0]);
  close(p[1]);
  exec("/bin/wc", argv);
} else {
  close(p[0]);
  write(p[1], "hello world\n", 12);
  close(p[1]);
}
```

程序调用`pipe`函数，创建新的管道并将读写文件描述符记录在数组`p`中。 在`fork`之后，父进程和子进程都拥有与该管道相关的文件描述符。 子进程调用`close`和`dup`函数，使文件描述符0指向管道的读取端，关闭了`p`中的文件描述符，并调用`exec`函数运行`wc`程序。 当`wc`从标准输入读取时，它实际上是从管道中读取数据。 父进程关闭了管道的读取端，在管道中写入数据后，再关闭了写入端。

如果没有数据可用，`read`函数会等待数据被写入或所有指向写入端的文件描述符关闭。如果是后一种情况，`read`会返回0，就像达到数据文件尾部一样。 事实上，`read`函数不断等待新数据到来就是一个重要原因，所以在执行`wc`前，子进程关闭管道的写入端。如果`wc`的任何一个文件描述符指向管道的写入端，`wc`将永远不会收到文件尾标记。

xv6 shell按照上述代码类似的方式实现管道，例如`grep fork sh.c | wc -l`。 子进程创建一个管道将管道左端连接到管道右端。然后，它为管道左端调用`fork`和`runcmd`，为管道右端调用`fork`和`runcmd`，并等待两端都执行完毕。 管道的右端可以是一个包含管道的命令（例如`a|b|c`），它本身会fork两个新的子进程（一个用于`b`，一个用于`c`）。因此，Shell可以创建进程树，其中树叶是命令，内部节点是等待左右子节点完成的进程。

管道或许看起来并不比临时文件更强大，例如下面的管道：

```bash
echo hello world | wc
```

下面是一个可以不用管道实现的例子：

```bash
echo hello world >/tmp/xyz; wc </tmp/xyz
```

在这个情况下，管道至少比临时文件具有以下三个优点。 首先，管道会自动清理；而使用文件重定向，则需要谨慎地在完成后删除/tmp/xyz文件。 其次，管道可以传递任意长的数据流，而文件重定向需要足够的磁盘空间来存储所有数据。 第三，管道允许管道阶段的并行执行，而文件方式要求第一个程序先完成后才能开始执行第二个程序。

## 1.4 文件系统

xv6文件系统提供了数据文件，它们包含未解释的字节数组，以及目录，它们包含数据文件和其他目录的命名引用。目录形成了一个树，从名为根的特殊目录开始。例如路径`/a/b/c`指的是在位于根目录`/`下的名为`a`的目录中，名为`b`的目录中，名为`c`的文件或目录。以非`/`字符开头的路径相对于调用进程的当前目录进行求值，可以使用`chdir`系统调用更改当前目录。下面这两个代码片段打开的是同一个文件（假设所有涉及的目录都存在）：

```C
chdir("/a");
chdir("b");
open("c", O_RDONLY);

open("/a/b/c", O_RDONLY);
```

第一个代码片段将进程的当前目录更改为`/a/b`；第二个代码片段既不涉及也不更改进程的当前目录。

有一些系统调用可以创建新文件和目录：`mkdir`创建新目录，带有`O_CREATE`标志的`open`命令则创建新数据文件，而`mknod`则创建新设备文件。下面的示例涵盖了这三个：

```C
mkdir("/dir");
fd = open("/dir/file", O_CREATE|O_WRONLY);
close(fd);
mknod("/console", 1, 1);
```

`mknod`会创建一个指向设备的特殊文件。与设备文件相关的还有主设备号和次设备号（`mknod`的两个参数），它们唯一标识内核设备。当一个进程打开设备文件时，内核将`read`和`write`系统调用转向内核设备实现，而不是传递给文件系统。

文件的名称与文件本身是不同的，称为inode（索引节点）的底层文件可以有多个名称（称为链接）。每个链接都由目录中的一个条目组成，该条目包含文件名和对inode的引用。inode保存文件的元数据，包括其类型（文件、目录或设备）、长度、文件内容在磁盘上的位置以及指向该文件的链接数。

`fstat`系统调用从文件描述符所指向的inode中检索信息。它填充一个`struct stat`，该结构在`stat.h`（kernel/stat.h）中定义如下：

```C
#define T_DIR     1   // Directory
#define T_FILE    2   // File
#define T_DEVICE  3   // Device

struct stat {
  int dev;     // File system's disk device
  uint ino;    // Inode number
  short type;  // Type of file
  short nlink; // Number of links to file
  uint64 size; // Size of file in bytes
};
```

系统调用`link`创建另一个文件系统名称，该名称引用与现有文件相同的inode。下面的代码片段创建了一个新文件，其名称既是`a`也是`b`，同时与现有文件的inode相同：

```C
open("a", O_CREATE|O_WRONLY);
link("a", "b");
```

对`a`进行读取或写入与对`b`进行读取或写入是相同的。每个inode由唯一的inode号进行标识。在上面的代码序列执行之后，可以通过检查`fstat`的结果来确定`a`和`b`引用相同的文件内容。这两个函数都将返回相同的inode号（`ino`），`nlink`计数将设置为2。

系统调用`unlink`从文件系统中删除一个名称。只有当文件的链接计数为零且没有文件描述符引用它时，文件的inode和保存其内容的磁盘空间才会被释放。因此，执行以下操作：

```C
unlink("a");
```

执行以下操作不会删除任何一件事情，它们两个都可以访问inode和文件内容：

```C
fd = open("/tmp/xyz", O_CREATE|O_RDWR);
unlink("/tmp/xyz");
```

Unix提供了可从Shell调用的文件实用程序，例如`mkdir`、`ln`和`rm`等用户级程序。这个设计允许任何人通过添加新的用户级程序来扩展命令行界面。回过头来看，这个计划似乎很明显，但当时设计的其他系统通常将这些命令构建到Shell中（并将Shell构建到内核中）。

一个例外是`cd`，它是内置于Shell中的。`cd`必须更改Shell本身的当前工作目录。如果`cd`被运行为常规命令，则Shell会派生出一个子进程，子进程运行`cd`，并且`cd`会更改子目录的工作目录，而父进程（即Shell的）工作目录不会更改。

## 1.5 实际情况

Unix通过“标准”文件描述符、管道以及方便的Shell语法对它们进行操作的组合，在编写通用可重复使用程序方面取得了重大进展。这个理念引发了“软件工具”的一种文化，这种文化为Unix的强大和普及做出了贡献，而Shell则是第一个所谓的“脚本语言”。Unix系统调用接口今天仍然存在于像BSD、Linux和macOS等系统中。

Unix系统调用接口已经通过可移植操作系统接口（POSIX）标准进行了标准化。Xv6*不是*POSIX兼容的：它缺少许多系统调用（包括基本的`lseek`等），而且它提供的很多系统调用与标准不同。我们给xv6的主要目标是提供一个简单明了、UNIX风格的系统调用接口。一些人已经通过增加一些系统调用和一个简单的C库来扩展xv6，以便运行基本的Unix程序。然而，现代内核提供了许多更多的系统调用和更多种类型的内核服务，比xv6提供的要多得多。例如，它们支持网络、窗口系统、用户级线程、大量设备的驱动程序等。现代内核持续而迅速地发展，并提供比POSIX更多的功能。

Unix使用一个通用的文件名和文件描述符接口统一访问多种类型的资源（文件、目录和设备）。这个理念可以扩展到更多类型的资源；一个很好的例子是Plan 9，它将“资源就是文件”的概念应用于网络、图形等更多的方面。然而，大多数Unix派生的操作系统并没有沿着这条路走。

文件系统和文件描述符是强大的抽象层。即便如此，操作系统接口的其它模型也可以被应用。Unix的前身Multics以一种使文件存储看起来像存储器的方式进行抽象，产生了一种非常不同的接口类型。Multics设计的复杂性直接影响了Unix的设计者，他们的目标是构建一个更为简单的系统。

xv6没有提供用户的概念，也没有实现保护一个用户不受其他用户干扰。换言之，在Unix术语中，所有的xv6进程都以root身份运行。

本书探讨了xv6如何实现其类Unix接口，但这些思想和概念不仅适用于Unix。任何操作系统都必须将进程多路复用到底层硬件上，将进程隔离开来，提供受控的进程间通信机制。在学习了xv6之后，您应该能够查看其他更复杂的操作系统，并在这些系统中看到xv6所基于的概念。

## 1.6 练习

1. 编写一个使用UNIX系统调用通过一对管道来回传递一个字节的程序，一个管道用于每个方向。通过每秒交换次数来测量程序的性能。
