# Chapter 4

# 陷阱和系统调用

CPU会出现三种类型的事件：系统调用、异常和设备中断，这些事件会迫使CPU暂停普通的指令执行，转而执行一些特殊的代码来处理事件。当一个用户程序执行`ecall`指令请求内核为其执行某些任务，即发起系统调用时，系统调用就会发生。当指令（用户或内核）执行一些非法操作时，例如除以零或使用无效虚拟地址，异常就会发生。当设备发出信号说明需要处理，例如磁盘硬件完成读取或写入请求时，设备中断就会发生。

本书使用`trap`(陷阱)作为这些情况的通用术语。通常，被打断的代码需要继续执行，而不需要意识到发生了特殊情况。也就是说，我们通常希望陷阱是透明的；这对于设备中断特别重要，因为被中断的代码通常不希望发生中断。通常的顺序是，陷阱强制控制转移到内核；内核保存寄存器和其他状态，以便可以继续执行；内核执行适当的处理程序代码（例如系统调用实现或设备驱动程序）；内核恢复保存的状态并从陷阱返回；原始代码从中断位置继续执行。

在xv6中，所有的陷阱都在内核中处理；陷阱不会被传递给用户代码。对于系统调用，内核中处理陷阱是很自然的。只允许内核使用设备，并且内核是在多个进程之间共享设备的方便机制，所以对于中断也是有意义的。对于异常也是有意义的，因为xv6会杀死所有来自用户空间的异常程序。

xv6的陷阱处理分为四个阶段：RISC-V CPU执行的硬件操作、一些汇编指令准备内核C代码、决定如何处理陷阱的C函数、以及系统调用或设备驱动服务例程。尽管三种陷阱类型之间通用性很强，但事实证明有个别的代码适用于三种不同情况：来自用户空间的陷阱、来自内核空间的陷阱和定时器中断。处理陷阱的内核代码（汇编或C）通常称为处理程序；第一个处理程序指令通常用汇编语言编写（而不是C语言），有时称为向量。

## RISC-V陷阱机制

每个RISC-V CPU都有一组控制寄存器，内核写入这些寄存器来告诉CPU如何处理陷阱，内核也可以读取它们来了解发生的陷阱。RISC-V文档包含完整的说明。`riscv.h`(kernel/riscv.h:1) 包含xv6使用的定义。以下是最重要的寄存器概述：


- `stvec`: 内核将其陷阱处理程序的地址写入此处；RISC-V跳转到`stvec`中的地址来处理陷阱。

- `sepc`: 当陷阱发生时，RISC-V将程序计数器（`pc`）保存在这里（因为 `pc` 随后被`stvec`中的值覆盖）。`sret`（从陷阱返回）指令将`sepc`复制到`pc`。内核可以写入`sepc`来控制`sret`返回的位置。

- `scause`: RISC-V在这里放置一个数字，描述陷阱的原因。

- `sscratch`: 陷阱处理程序代码使用`sscratch`来帮助避免在保存它们之前覆盖用户寄存器。

- `sstatus`：`sstatus`中的SIE位控制设备中断是否启用。如果内核清除了SIE，则RISC-V会推迟设备中断，直到内核设置了SIE。SPP位指示陷阱是从用户模式还是超级用户模式发生的，并控制`sret`返回的模式。

以上寄存器与在超级用户模式下处理的陷阱相关，并且在用户模式下不能读取或写入。在机器模式下处理的陷阱也有类似的一组控制寄存器；xv6仅用于定时器中断的特殊情况。

多核芯片上的每个CPU都有自己的一组这些寄存器，且可能同时有多个CPU在处理陷阱。

当需要强制发生陷阱时，RISC-V硬件对于所有陷阱类型（除定时器中断之外）都执行以下操作：

1. 如果陷阱是设备中断，并且 `sstatus` 寄存器的 SIE 位被清除，则不执行以下任何操作。
2. 通过清除 `sstatus` 寄存器中的 `SIE` 位来禁用中断。
3. 将 pc 寄存器的值复制到 `sepc` 寄存器中。
4. 将当前运行模式（用户或超级用户）保存到 `sstatus` 寄存器的 `SPP` 位中。设置 `scause` 寄存器以反映陷阱的原因。
5. 将当前模式设置为超级用户模式。
6. 将 `stvec` 寄存器的值复制到 pc 寄存器中。

注意，CPU在陷阱期间不会切换到内核页表，也不会切换到内核中的堆栈，并且不会保存除`pc`以外的任何寄存器。内核软件必须执行这些任务。CPU在陷阱期间减少工作量的其中一个原因是为软件提供灵活性；例如，某些操作系统在某些情况下省略页表切换以提高陷阱性能。

值得思考的是，上述列出的步骤中是否可以省略任何步骤，或许是为了寻求更快的陷阱执行。虽然有一些情况可以使用更简单的顺序，但通常省略许多步骤将是危险的。例如，如果CPU没有切换程序计数器，则来自用户空间的陷阱可以在仍运行用户指令的情况下切换为超级用户模式。这些用户指令可能会打破用户/内核隔离，例如通过修改`satp`寄存器以指向允许访问所有物理内存的页表。因此，CPU切换到内核指定的指令地址，即`stvec`，非常重要。

## 来自用户空间的陷阱

在xv6中，处理陷阱会根据陷阱发生时是在内核执行还是在用户代码执行有所不同。本节将讲述来自用户代码的陷阱处理，而第4.5节则讨论内核代码的陷阱处理。

如果用户程序进行系统调用（`ecall`指令）或做了一些不合法的操作，或者设备产生了中断，则可能会在用户空间执行时发生陷阱。一次从用户空间出发的陷阱的高级路径依次经过`uservec`、`usertrap`、`usertrapret`，并在返回时经过`userret`。

RISC-V硬件在强制触发陷阱时不会切换页表，这是影响xv6陷阱处理的主要限制。这意味着`stvec`中的陷阱处理程序地址必须有一个在用户页表中的有效映射，因为在处理陷阱代码开始执行时，该页表是有效的。此外，xv6陷阱处理代码需要切换到内核页表，为了能够在这种切换之后继续执行，内核页表还必须有一个指向`stvec`所指向的处理程序的映射。

xv6使用一个*trampoline*页面来满足这些要求。trampoline页面包含`stvec`指向的xv6陷阱处理代码`uservec`。该页面在每个进程的页面表中都映射到`TRAMPOLINE`地址，该地址在虚拟地址空间的顶部，这样就可以位于程序给自己使用的内存上方。trampoline页面在内核页表中的地址也映射到了`TRAMPOLINE`地址。详见图2.3和图3.3。因为trampoline页面是在用户页面表中映射的，没有`PTE_U`标记，因此陷阱可以在超级模式下开始在该页面上执行。由于trampoline页面在内核地址空间中的地址与用户空间中的地址相同，所以在切换到内核页表之后，陷阱处理程序仍然可以继续执行。

`uservec`的陷阱处理程序代码定义在`trampoline.S`文件中。当`uservec`开始运行时，所有32个寄存器都包含中断的用户代码拥有的值。这32个值需要被保存到内存中，以便在陷阱返回到用户空间时可以恢复它们。保存到内存需要使用一个寄存器来保存地址，但此时没有通用寄存器可用！幸运的是，RISC-V在`sscratch`寄存器中提供了帮助。`uservec`的开头处的`csrw`指令将`a0`保存在`sscratch`中。现在，`uservec`有一个寄存器`a0`可以使用。

`uservec`的下一个任务是保存32个用户寄存器。内核为每个进程分配了一个内存页面作为`trapframe`结构体，用于保存这32个用户寄存器，该结构体还包含了当前进程的内核栈地址、当前CPU的hartin、`usertrap`函数的地址、内核页表的地址等信息。因为`uservec`引用了用户页表，`trapframe`还需要在用户地址空间映射。xv6在每个进程的用户页表中将其映射到`trapframe`虚拟地址；由于`trapframe`位于`TRAMPOLINE`下方，所以可以保证用户程序不会覆盖该内存。进程的`p->trapframe`也指向该`trapframe`，但指向其物理地址，因此内核可以在内核页表中使用它。

因此，`uservec`将地址`trapframe`加载到`a0`中，并将所有用户寄存器保存在其中，包括从`sscratch`读回的用户寄存器的`a0`。

`trapframe`包含当前进程的内核栈地址、当前CPU的hartin值、`usertrap`函数的地址和内核页表的地址。`uservec`检索这些值，将`satp`切换到内核页表，并调用`usertrap`。

`usertrap`的任务是确定陷阱的原因，并进行处理和返回。它首先将`stvec`更改为指向`kernelvec`而不是`uservec`，以便在内核中发生陷阱时进行处理。它保存了`sepc`寄存器（保存的用户程序计数器），因为`usertrap`可能调用`yield`以切换到另一个进程的内核线程，并且该进程可能返回到用户空间，在此过程中它将修改`sepc`的值。如果陷阱是系统调用，则`usertrap`调用`syscall`来处理；如果是设备中断，则调用`devintr`进行处理；否则就是异常，内核终止了错误的进程。系统调用路径会将保存的用户程序计数器加上4，因为在系统调用的情况下，RISC-V会将程序指针指向`ecall`指令，但是用户代码需要在后续指令中继续执行。在返回时，`usertrap`检查进程是否已被终止或应该yield CPU（如果这是一个定时器中断）。

返回到用户空间的第一步是调用`usertrapret`。该函数设置RISC-V控制寄存器，以准备未来来自用户空间的陷阱处理。这包括将`stvec`更改为指向`uservec`，准备`trapframe`字段以供`uservec`使用，并将`sepc`设置为之前保存的用户程序计数器。最后，`usertrapret`在内核和用户页面表中都映射的trampoline页面上调用`userret`，因为`userret`汇编代码中会切换页表。

`usertrapret`调用`userret`时通过`a0`传递了进程的用户页面表的指针。`userret`将`satp`切换到该进程的用户页表。请注意，用户页表除了内核方面的trampoline页面和`trapframe`之外，其他都不能映射任何内存。由于trampoline页面在用户和内核页面表中具有相同的虚拟地址映射，`userret`可以在切换`satp`之后继续执行。从这一点开始，`userret`唯一能够使用的数据是寄存器内容和`trapframe`中的内容。`userret`将`trapframe`地址加载到`a0`中，从`a0`中的`trapframe`中恢复保存的用户寄存器，包括从`sscratch`恢复的用户`a0`，然后执行`sret`返回到用户空间。

## 代码:使用系统调用

第2章以调用`exec`系统调用结束。 让我们看看用户调用如何到达内核的`exec`系统调用实现。

`initcode.S`将`exec`的参数放入寄存器`a0`和`a1`，并将系统调用号放入`a7`中。 系统调用号匹配`syscalls`数组中的条目，`syscalls`是一个指向函数指针的表。 `ecall`指令会陷入内核，并导致先执行`uservec`、`usertrap`和`syscall`，正如我们上面看到的。

`syscall`从陷阱帧中保存的`a7`中检索出系统调用号，并将其用于索引到`syscalls`数组。 对于第一个系统调用，\texttt{a7}包含`SYS_exec`，导致调用系统调用实现函数`sys_exec`。

当`sys_exec`返回时，`syscall`将其返回值记录在`p->trapframe->a0`中。 这将导致原始的用户空间调用`exec()`返回该值，因为在RISC-V上，C调用约定将返回值放在`a0`中。 约定上，系统调用返回负数表示错误，返回零或正数表示成功。 如果系统调用号无效，`syscall`会输出错误并返回−1。

## 代码:系统调用参数
内核中的系统调用实现需要找到用户代码传递的参数。因为用户代码调用了系统调用包装函数，所以参数最初位于RISC-V C调用约定放置它们的寄存器中。

内核陷阱代码将用户寄存器保存到当前进程的陷阱帧中，内核代码可以从中找到它们。内核函数`argint`、`argaddr` 和`argfd`从陷阱帧中获取第n个系统调用参数，作为整数、指针或文件描述符。它们都调用`argraw`来检索适当保存的用户寄存器。

一些系统调用将指针作为参数传递，内核必须使用这些指针来读取或写入用户内存。例如，`exec`系统调用将一个指向用户空间字符串参数的指针数组传递给内核。这些指针带来了两个挑战。首先，用户程序可能存在错误或恶意，并且可能会传递给内核一个无效的指针或一个旨在欺骗内核访问内核内存而不是用户内存的指针。其次，xv6内核页表映射与用户页表映射不同，因此内核无法使用普通指令从用户提供的地址加载或存储。

内核实现了函数以安全地传输数据到和从用户提供的地址。文件系统调用，比如`exec`，使用`fetchstr`从用户空间检索字符串文件名参数。`fetchstr`调用`copyinstr`来完成难以处理的工作。

`copyinstr`函数从用户页表`pagetable`中将虚拟地址`srcva`处的字符串复制到虚拟地址`dst`中。由于`pagetable`不是当前的页表，`copyinstr`使用`walkaddr`（调用`walk`）在`pagetable`中查找`srcva`，得到物理地址`pa0`。内核将每个物理RAM地址映射到相应的内核虚拟地址，因此`copyinstr`可以直接从`pa0`复制字符串字节到`dst`。`walkaddr`检查用户提供的虚拟地址是否属于该进程的用户地址空间，因此程序无法欺骗内核读取其他内存。类似的函数`copyout`将数据从内核复制到用户提供的地址。

## 从内核空间的陷阱

Xv6根据执行者是用户代码还是内核代码，在配置CPU陷阱寄存器时采取了有点不同的方式。当CPU上的内核正在执行时，内核将`stvec`指向`kernelvec`汇编代码的地址。

由于xv6已经在内核中了，所以`kernelvec`可以确保`satp`已设置为内核页表，并且栈指针指向有效的内核栈。 `kernelvec`将所有32个寄存器都推到栈上，稍后将它们恢复，以便中断的内核代码可以不受干扰地继续运行。

`kernelvec`将寄存器保存在中断的内核线程的栈上，这是有意义的，因为寄存器值属于该线程。如果陷阱导致切换到不同的线程，则陷阱实际上将从新线程的栈中返回，从而将中断的线程的保存寄存器安全地留在其栈中。

`kernelvec`跳转到`kerneltrap`。 `kerneltrap`准备处理两种类型的陷阱：设备中断和异常。它调用`devintr`来检查并处理前者。 如果陷阱不是设备中断，则必须是异常。如果在xv6内核中发生异常，则总是致命错误。内核会调用`panic`并停止执行。

如果`kerneltrap`由于计时器中断而调用，并且进程的内核线程正在运行（而不是调度程序线程），`kerneltrap`将调用`yield`，让其他线程有机会运行。在某个时刻，其中一个线程将让出，让我们的线程和它的`kerneltrap`再次恢复。第7章解释了`yield`中会发生什么。

当`kerneltrap`完成其工作后，它需要返回到由陷阱中断的任何代码。由于yield可能已经扰乱`sepc`和`sstatus`中的前一个模式，因此`kerneltrap`在开始时保存它们。现在它恢复这些控制寄存器并返回到`kernelvec`。`kernelvec`从堆栈中弹出保存的寄存器并执行`sret`，这将`sepc`复制到`pc`中并恢复中断的内核代码。

值得思考的是，如果`kerneltrap`由于计时器中断而调用了`yield`，那么中断返回会发生什么。

当CPU从用户空间进入内核时，Xv6将该CPU的`stvec`设置为`kernelvec`，可以在`usertrap`中看到这一点。这时，内核已经开始执行，但`stvec`仍然设置为`uservec`，这是一段时间的窗口，非常关键的是，在该窗口期间不会发生设备中断。幸运的是，RISC-V始终在开始陷阱时禁用中断，直到它设置了`stvec`之后，xv6才会再次启用中断。

## Page-fault 异常

Xv6对异常的响应非常无聊：如果在用户空间发生异常，内核会终止出现错误的进程。如果在内核空间发生异常，内核会发生崩溃。真实的操作系统往往会采用更有趣的方式进行响应。

举个例子， 许多内核使用页面错误来实现写时复制(COW)fork。 为了解释写时复制fork，考虑第\ref{CH:MEM}章描述的xv6的fork。 fork使子进程的初始内存内容与fork时的父进程相同。 Xv6使用uvmcopy实现 fork, 该函数会为子进程分配物理内存，并将父进程的内存复制到子进程中。 如果子进程和父进程可以共享父进程的物理内存，效率会更高。 然而，直接共享无法工作，因为它会导致父进程和子进程通过共享栈和堆来打断彼此的执行。

通过合理地使用页面表权限和页面错误，父进程和子进程可以安全地共享物理内存。 当页面表中没有映射虚拟地址或映射的PTE_V标志未设置或映射的权限位(PTE_R、PTE_W、PTE_X、PTE_U)禁止尝试的操作时，CPU会引发 页面错误异常。 在RISC-V中，有三种页面错误: 页面加载错误（当加载指令无法转换其虚拟地址时）， 页面存储错误（当存储指令无法转换其虚拟地址时）和指令页面错误（当程序计数器中的地址无法转换时）。 `scause`寄存器指示页面错误类型，`stval`寄存器包含无法转换的地址。

COW fork的基本计划是将父进程和子进程最初共享所有物理页面，但每个进程将其映射为只读（PTE_W标志未设置）。 父进程和子进程都可以从共享物理内存中读取。 如果任一方写入给定的页面，则RISC-V CPU会引发页面错误异常。 内核的陷阱处理程序通过分配一个新的物理内存页并将页内的物理页复制到其中来响应。异常处理程序更改故障进程页面表中相关的PTE， 以指向副本并允许写入以及读取，然后在导致异常的指令处恢复故障进程。由于 PTE允许写入，重新执行的指令 现在会执行而不会触发异常。写时复制需要进行簿记以帮助决定何时可以释放物理页，因为每个物理页的引用量取决于forks、页面错误、execs和exit的历史记录。 这种簿记使得一个重要的优化成为可能：如果一个进程遇到了一个存储页面 故障和物理页面仅被该进程的页面表引用，则不需要复制。

写时复制让fork更快，因为fork无需复制内存。一些内存以后可能需要复制 当写入时，但通常情况下，大多数内存永远不必被复制。 常见的情况是fork之后的exec： fork之后可能写入一些页面， 但是然后子进程的exec会释放从父进程继承的大部分内存。 写时复制fork消除了 永远不需要复制这个内存的需要。 此外，COW fork是透明的： 应用程序不需要进行任何修改以获得收益。

页面表和页面错误的组合在除了COW fork之外还可开启一系列有趣的可能性。另一个被广泛使用的特点是称为惰性分配， 该特点具有两个部分。首先，当应用程序通过调用 `sbrk`请求更多内存时，内核会注意到大小的增加，但不会 分配物理内存，并且不会为新的虚拟地址范围创建PTE。其次，在其中一个新页面发生页面错误时， 内核会分配一个物理内存页面并将其映射到页面表中。 像COW fork一样， 内核可以透明地实现惰性分配以应用程序。

由于应用程序通常会请求比所需内存更多的内存，因此惰性分配是有益的：对于应用程序从未使用的页面，内核无需做任何工作。 此外，如果应用程序要增加地址空间的大小，则不使用惰性分配的`sbrk`是昂贵的: 如果应用程序请求1 GB内存，则内核必须分配并清零262,144个4096 bytes页。 惰性分配允许将此成本逐步分摊。另一方面，惰性分配会增加页面错误的额外开销，这涉及到内核/用户转换。 操作系统可以通过一次页面错误分配一批相邻的页面（而不是一个页面），并将内核 entry/exit代码特殊化处理这种页面错误来减少这种成本。

利用页面错误的另一个广泛使用功能是称为按需分页。在`exec`中，xv6会立即将应用程序的所有文本和数据加载到内存中。因为应用程序可能很大， 并且从磁盘读取很耗时，这种启动成本可能会对用户产生影响：当用户从shell启动大型应用程序时， 可能需要很长时间才能看到响应。 为了改善响应时间，现代内核会为用户地址空间创建页面表，但是标记页面的PTE无效。在一个页面错误上， 内核从磁盘中读取页面的内容，并将其映射到用户地址空间中。像COW fork和惰性分配一样，内核可以透明地实现此功能到应用程序中。

运行在计算机上的程序可能需要比计算机拥有的RAM更多的内存。 为了优雅地处理这种情况，操作系统可能会实现 页面换出。 页面换出的思想是仅将用户页面的一部分存储在RAM中，将其余页面存储在磁盘的分页区域中。内核标记指向内存存储的PTE（因此不在RAM中）的PTE无效。如果 应用程序试图使用已经被交换到磁盘上的页面之一，则应用程序将发生页面错误，必须将该页面交换回来: 内核陷阱处理程序将分配一个物理RAM页面，并将该页面从磁盘读入RAM， 然后修改相关的PTE，以便指向RAM。

如果需要交换回页面，但没有空闲的内存会发生什么情况？在这种情况下，内核必须首先通过将其换出或将其推出到磁盘上来释放物理页，并将引用该物理页的PTE标记为无效。换出是昂贵的，因此页面换出的表现最佳，如果应用程序仅使用其内存页面的一个子集，并且这些子集的并集适合于RAM。通常称这种属性为具有良好的参考局部性。与许多虚拟内存技术一样，内核通常以对应用程序透明的方式实现页面换出到磁盘。

计算机通常在很少或几乎没有空闲物理内存的情况下运行，无论硬件提供了多少RAM。例如，云提供商在一台机器上复用多个客户以实现成本效益。另一个例子是用户在较小的物理内存上运行许多智能手机应用程序。在这种情况下，分配一页可能需要先驱逐一个现有的页面。因此，当空闲物理内存稀缺时，分配是昂贵的。

惰性分配和按需分页在空闲内存稀缺时特别有优势。 在`sbrk`或`exec`中急切地分配内存会付出额外的代价，需要驱逐页面以腾出内存。此外，出于在应用程序使用该页面之前操作系统可能已将其删除的风险，急切分配的工作可能是徒劳的。

结合分页和页故障异常的其他特性包括自动扩展栈和内存映射文件。

## 实际情况

Trampoline和trapframe可能看起来过于复杂。其驱动力是，RISC-V在强制陷阱时尽可能少地执行操作，以允许非常快速的陷阱处理，这证明是非常重要的。因此，内核陷阱处理程序的前几条指令实际上必须在用户环境中执行：用户页表和用户寄存器内容。并且初始状态下，陷阱处理程序对有用的事实是无知的，例如正在运行的进程的身份或内核页表的地址。这是因为RISC-V在进入用户空间之前提供内核可以暂时存储信息的保护位置：`sscratch`寄存器和用户页表条目，其指向内核内存但受`PTE_U'的缺乏保护。Xv6的trampoline和trapframe利用了这些RISC-V特性。

如果将内核内存映射到每个进程的用户页表中（使用适当的PTE权限标志），则可以消除特殊的trampoline页面的需要。这也会消除从用户空间陷阱进入内核时对页表切换的需要。这反过来将允许内核中的系统调用实现利用当前进程的用户内存被映射，从而允许内核代码直接引用用户指针。许多操作系统已经使用这些想法来提高效率。然而，Xv6避免这种方法以降低由于意外使用用户指针而导致的内核安全漏洞的可能性，并降低了一些必要的复杂性，以确保用户和内核虚拟地址不重叠。

生产操作系统实现了写时复制fork、惰性分配、按需分页、将页面换出到磁盘、内存映射文件等。此外，生产操作系统将尝试使用所有物理内存，无论其是用于应用程序还是用于缓存（例如文件系统缓冲区高速缓存，我们将在第8.2节中介绍）。Xv6在这方面显得比较幼稚：您希望操作系统使用您购买的物理内存，但xv6没有这样做。此外，如果xv6耗尽了内存，它会向运行的应用程序返回错误或终止它，而不是例如驱逐另一个应用程序的页面。

## 练习

1. 函数`copyin`和`copyinstr`会使用软件遍历用户页表。设置内核页表，使得内核映射了用户程序，并且`copyin`和`copyinstr`可以使用`memcpy`将系统调用参数复制到内核空间，依靠硬件来执行页表遍历。
2. 实现惰性内存分配。
3. 实现写时复制fork。
4. 是否有一种方法可以消除在每个用户地址空间中特定的`trapframe`页面映射？例如，`uservec`是否可以修改为将32个用户寄存器直接推入内核栈，或者将它们存储在`proc`结构中？
5. xv6是否可以被修改以消除特定的`TRAMPOLINE`页面映射？ 
